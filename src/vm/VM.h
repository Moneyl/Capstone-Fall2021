#pragma once
#include "Typedefs.h"
#include "VmProgram.h"
#include "utility/Result.h"
#include "utility/Span.h"
#include "Instruction.h"
#include "VM.h"
#include <unordered_map>

struct VMError;

//Virtual machine that runs binaries generated by Compiler.
class VM
{
public:
    //Constants
    static const u32 RESERVED_BYTES = 256; //Bytes at the start of VM memory reserved for ports and other VM data
    static const u32 MEMORY_SIZE = 32766; //Note: Less than VmValue max so SP can be set out of bounds to signify an empty stack
    static const u32 NUM_REGISTERS = 8;
    static_assert(MEMORY_SIZE <= std::numeric_limits<Register>::max(), "VM::MEMORY_SIZE too big! Must be fit inside VM registers. Either make memory smaller or make registers larger (see VM.h)");
    
    Result<void, VMError> LoadProgram(const VmProgram& program); //Load program binary
    Result<void, VMError> LoadProgram(std::string_view inFilePath); //Load program binary from file
    Result<void, VMError> LoadProgramFromSource(std::string_view inFilePath); //Compile and load program from source file
    Result<void, VMError> Cycle(); //Run a single clock cycle
    VmValue Load(VmValue address); //Read value from VM memory
    void Store(VmValue address, VmValue value); //Set value in VM memory
    void Push(VmValue value); //Push a value onto the stack
    VmValue Pop(); //Pop a value off of the stack
    void SetFlags(VmValue result); //Update arithmetic flags

    u32 InstructionsSize() const { return _instructionsSizeBytes; } //The number of bytes that instructions take up in memory
    u32 VariablesSize() const { return _variablesSizeBytes; } //The number of bytes that variables take up in memory
    u32 StackSize() const { return VM::MEMORY_SIZE - SP; } //The number of bytes that the stack is using currently
    u32 MaxStackSize() const { return VM::MEMORY_SIZE - VM::RESERVED_BYTES - InstructionsSize() - VariablesSize(); } //Max bytes the stack can use

    //Get a non-owning view of the program instructions
    const Span<Instruction> Instructions() { return Span<Instruction>((Instruction*)&Memory[VM::RESERVED_BYTES], InstructionsSize() / sizeof(Instruction)); };
    //Get a non-owning view of the programs variables
    const Span<VmValue> Variables() { return Span<VmValue>((VmValue*)&Memory[VM::RESERVED_BYTES + InstructionsSize()], VariablesSize() / sizeof(VmValue)); };

    u8 Memory[VM::MEMORY_SIZE] = { 0 };
    Register Registers[VM::NUM_REGISTERS] = { 0 };
    Register PC = VM::RESERVED_BYTES; //Memory address of the next instruction to be executed
    Register SP = VM::MEMORY_SIZE; //Memory address of the top of the stack. Initially just past the end of Memory. Grows down from the top of Memory.

    //Set with the result of arithmetic instructions and with the difference between registers when cmp is executed. Used by conditional jump instructions like jle and jgr.
    bool FlagZero = false; //True when result == 0
    bool FlagSign = false; //True when result < 0

private:
    //Executes _instruction and increments PC
    Result<void, VMError> Execute();

    u32 _instructionsSizeBytes = 0; //The number of bytes that the program takes up in memory
    u32 _variablesSizeBytes = 0; //The number of bytes that variables take up in memory

    //Current instruction being executed by the VM. Used for instructions that take > 1 cycle to execute.
    Instruction* _instruction = nullptr;
    u32 _instructionCyclesRemaining = 0;

public:
    //The number of cycles it takes to execute each instruction
    const std::unordered_map<Opcode, u32> InstructionTimes =
    {
        { Opcode::Mov,    1 },
        { Opcode::MovVal, 1 },
        { Opcode::Add,    1 },
        { Opcode::AddVal, 1 },
        { Opcode::Sub,    1 },
        { Opcode::SubVal, 1 },
        { Opcode::Mul,    2 },
        { Opcode::MulVal, 2 },
        { Opcode::Div,    2 },
        { Opcode::DivVal, 2 },
        { Opcode::Cmp,    1 },
        { Opcode::CmpVal, 1 },
        { Opcode::Jmp,    1 },
        { Opcode::Jeq,    1 },
        { Opcode::Jne,    1 },
        { Opcode::Jgr,    1 },
        { Opcode::Jls,    1 },
        { Opcode::Call,   1 },
        { Opcode::Ret,    1 },
        { Opcode::And,    1 },
        { Opcode::AndVal, 1 },
        { Opcode::Or,     1 },
        { Opcode::OrVal,  1 },
        { Opcode::Xor,    1 },
        { Opcode::XorVal, 1 },
        { Opcode::Neg,    1 },
        { Opcode::Load,   4 },
        { Opcode::LoadP,  4 },
        { Opcode::Store,  4 },
        { Opcode::StoreP, 4 },
        { Opcode::Push,   1 },
        { Opcode::Pop,    1 },
    };
};

enum VMErrorCode
{
    DivideByZero,
    OutOfBoundsMemoryAccess,
    StackUnderflow,
    StackOverflow,
    UnsupportedInstruction,
    ProgramFileLoadFailure,
};

//Returned when the VM encounters an error
struct VMError
{
    VMErrorCode Code;
    std::string Message;
};

static std::string to_string(VMErrorCode value)
{
    return std::string(magic_enum::enum_name(value));
}