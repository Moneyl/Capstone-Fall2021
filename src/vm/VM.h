#pragma once
#include "Typedefs.h"
#include "Compiler.h"
#include "utility/Span.h"
#include "utility/Result.h"
#include "Instruction.h"

struct VMError;
using VmValue = i16; //VM variable size
using Register = VmValue; //VM register size

//Virtual machine that runs binaries generated by Compiler.
class VM
{
public:
    //Constants
    static const u32 MEMORY_SIZE = 32767; //Note: 1 less than maximum of Register so SP can be one byte past the final memory index when the stack is empty
    static const u32 NUM_REGISTERS = 8;
    static_assert(MEMORY_SIZE <= std::numeric_limits<Register>::max(), "VM::MEMORY_SIZE too big! Must be fit inside VM registers. Either make memory smaller or make registers larger (see VM.h)");
    
    Result<void, VMError> Run(Span<Instruction> program); //Run a program until PC >= _programSize
    VmValue Load(VmValue address); //Read value from VM memory
    void Store(VmValue address, VmValue value); //Set value in VM memory
    void Push(VmValue value); //Push a value onto the stack
    VmValue Pop(); //Pop a value off of the stack
    void SetFlags(VmValue result); //Update arithmetic flags

    u32 ProgramSize() const { return _programSize; } //Returns the number of bytes that the program takes up in memory
    u32 VariablesSize() const { return _variablesSize; } //Returns the number of bytes that variables take up in memory

    u8 Memory[VM::MEMORY_SIZE] = { 0 };
    Register Registers[VM::NUM_REGISTERS] = { 0 };
    Register PC = 0; //Memory address of the next instruction to be executed
    Register SP = VM::MEMORY_SIZE; //Memory address of the top of the stack. Initially just past the end of Memory. Grows down from the top of Memory.

    //Set with the result of arithmetic instructions and with the difference between registers when cmp is executed. Used by conditional jump instructions like jle and jgr.
    bool FlagZero = false; //True when result == 0
    bool FlagSign = false; //True when result < 0

private:
    u32 _programSize = 0; //The number of bytes that the program takes up in memory
    u32 _variablesSize = 0; //The number of bytes that variables take up in memory
};

enum VMErrorCode
{
    DivideByZero,
    OutOfBoundsMemoryAccess,
    StackUnderflow,
    StackOverflow,
    UnsupportedInstruction,
};

//Returned when the VM encounters an error
struct VMError
{
    VMErrorCode Code;
    std::string Message;
};