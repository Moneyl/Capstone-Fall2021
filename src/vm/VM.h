#pragma once
#include "Typedefs.h"
#include "VmProgram.h"
#include "utility/Result.h"
#include "utility/Span.h"
#include "Instruction.h"
#include "Constants.h"
#include <unordered_map>
#include <functional>

struct VMError;

//Virtual machine that runs binaries generated by Compiler.
class VM
{
public:
    //Constants
    static const u32 RESERVED_BYTES = 256; //Bytes at the start of VM memory reserved for ports and other VM data
    static const u32 MEMORY_SIZE = 32766; //Note: Less than VmValue max so SP can be set out of bounds to signify an empty stack
    static const u32 NUM_REGISTERS = 8;
    static_assert(MEMORY_SIZE <= std::numeric_limits<Register>::max(), "VM::MEMORY_SIZE too big! Must be fit inside VM registers. Either make memory smaller or make registers larger (see VM.h)");
    
    Result<void, VMError> LoadProgram(const VmProgram& program); //Load program binary
    Result<void, VMError> LoadProgram(std::string_view inFilePath); //Load program binary from file
    Result<void, VMError> LoadProgramFromSource(std::string_view inFilePath); //Compile and load program from source file
    Result<void, VMError> Cycle(f32 deltaTime); //Run a single clock cycle. deltaTime is time since elapsed since last Cycle. Passed to port callbacks.
    VmValue Load(VmValue address); //Read value from VM memory
    void Store(VmValue address, VmValue value); //Set value in VM memory
    void Push(VmValue value); //Push a value onto the stack
    VmValue Pop(); //Pop a value off of the stack
    void SetFlags(VmValue result); //Update arithmetic flags
    VmValue& GetPort(Port port); //Get reference to a port

    u32 InstructionsSize() const { return _instructionsSizeBytes; } //The number of bytes that instructions take up in memory
    u32 VariablesSize() const { return _variablesSizeBytes; } //The number of bytes that variables take up in memory
    u32 StackSize() const { return VM::MEMORY_SIZE - SP; } //The number of bytes that the stack is using currently
    u32 MaxStackSize() const { return VM::MEMORY_SIZE - VM::RESERVED_BYTES - InstructionsSize() - VariablesSize(); } //Max bytes the stack can use

    //Get a non-owning view of the program instructions
    const Span<Instruction> Instructions() { return Span<Instruction>((Instruction*)&Memory[VM::RESERVED_BYTES], InstructionsSize() / sizeof(Instruction)); };
    //Get a non-owning view of the programs variables
    const Span<VmValue> Variables() { return Span<VmValue>((VmValue*)&Memory[VM::RESERVED_BYTES + InstructionsSize()], VariablesSize() / sizeof(VmValue)); };
    //Get the number of cycles it takes to execute an instruction. Returns u32_max if the instruction is unsupported.
    u32 GetInstructionDuration(const Instruction& instruction) const;

    std::optional<VmValue> GetConfig(const std::string& name);
    VmValue GetConfigOr(const std::string& name, VmValue or = 0);

    u8 Memory[VM::MEMORY_SIZE] = { 0 };
    Register Registers[VM::NUM_REGISTERS] = { 0 };
    Register PC = VM::RESERVED_BYTES; //Memory address of the next instruction to be executed
    Register SP = VM::MEMORY_SIZE; //Memory address of the top of the stack. Initially just past the end of Memory. Grows down from the top of Memory.

    //Set with the result of arithmetic instructions and with the difference between registers when cmp is executed. Used by conditional jump instructions like jle and jgr.
    bool FlagZero = false; //True when result == 0
    bool FlagSign = false; //True when result < 0

    //Called when ports are read or written to
    std::function<void(Port port, f32 deltaTime)> OnPortRead;  //Called before the VM stores the port value in a register. That way the callback can update the port value.
    std::function<void(Port port, VmValue value, f32 deltaTime)> OnPortWrite; //Called after the VM updates the port value. That way the callback can update the hardware with the new port value.

    //Config values
    std::vector<VmConfig> Config = {};

private:
    //Executes _instruction and increments PC
    Result<void, VMError> Execute(f32 deltaTime);

    u32 _instructionsSizeBytes = 0; //The number of bytes that the program takes up in memory
    u32 _variablesSizeBytes = 0; //The number of bytes that variables take up in memory

    //Current instruction being executed by the VM. Used for instructions that take > 1 cycle to execute.
    Instruction* _instruction = nullptr;
    u32 _instructionCyclesRemaining = 0;

public:
    //The number of cycles it takes to execute each instruction
    const std::unordered_map<Opcode, u32> InstructionDurations =
    {
        { Opcode::Mov,    1 },
        { Opcode::MovVal, 1 },
        { Opcode::Add,    1 },
        { Opcode::AddVal, 1 },
        { Opcode::Sub,    1 },
        { Opcode::SubVal, 1 },
        { Opcode::Mul,    2 },
        { Opcode::MulVal, 2 },
        { Opcode::Div,    2 },
        { Opcode::DivVal, 2 },
        { Opcode::Cmp,    1 },
        { Opcode::CmpVal, 1 },
        { Opcode::Jmp,    1 },
        { Opcode::Jeq,    1 },
        { Opcode::Jne,    1 },
        { Opcode::Jgr,    1 },
        { Opcode::Jls,    1 },
        { Opcode::Call,   1 },
        { Opcode::Ret,    1 },
        { Opcode::And,    1 },
        { Opcode::AndVal, 1 },
        { Opcode::Or,     1 },
        { Opcode::OrVal,  1 },
        { Opcode::Xor,    1 },
        { Opcode::XorVal, 1 },
        { Opcode::Neg,    1 },
        { Opcode::Load,   4 },
        { Opcode::LoadP,  4 },
        { Opcode::Store,  4 },
        { Opcode::StoreP, 4 },
        { Opcode::Push,   1 },
        { Opcode::Pop,    1 },
        //Note: ipo and both variants of opo ignore this and instead use PortDurations
        { Opcode::Ipo,    1 },
        { Opcode::Opo,    1 },
        { Opcode::OpoVal, 1 }
    };

    //The number of cycles it takes to read/write from each port.
    const std::unordered_map<Port, u32> PortDurations =
    {
        { Port::Spedometer,           1 },
        { Port::Heat,                 1 },
        { Port::Compass,              1 },
        { Port::Steering,             1 },
        { Port::TurretShoot,          1 },
        { Port::TurretRotateOffset,   1 },
        { Port::TurretRotateAbsolute, 1 },
        { Port::MineLayer,            1 },
        { Port::MineTrigger,          1 },
        { Port::Sonar,                1 },
        { Port::Radar,                3 },
        { Port::Scanner,              1 },
        { Port::ScannerArc,           1 },
        { Port::Throttle,             1 },
        { Port::Heat,                 1 },
        { Port::Compass,              1 },
        { Port::Armor,                1 },
        { Port::Random,               1 },
        { Port::Shield,               1 },
    };
};

enum VMErrorCode
{
    DivideByZero,
    OutOfBoundsMemoryAccess,
    StackUnderflow,
    StackOverflow,
    UnsupportedInstruction,
    ProgramFileLoadFailure,
};

//Returned when the VM encounters an error
struct VMError
{
    VMErrorCode Code;
    std::string Message;
};

static std::string to_string(VMErrorCode value)
{
    return std::string(magic_enum::enum_name(value));
}